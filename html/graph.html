<!DOCTYPE HTML>
<html>
<head>
    <script src="./vis-4.18.0/dist/vis.js"></script>
    <link href="./vis-4.18.0/dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Websocket client</title>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 600px;
            border: 1px solid lightgray;
        }

        p {
            max-width:600px;
        }

        h4 {
            margin-bottom:3px;
        }
        #infobar {
            border: 1px solid lightgray;
        }
    </style>
</head>
<body>

<h2>SPIN traffic data prototype</h2>

<div id="visualization"></div>
<div id="infobar">
    <div id="selected">Selected:</div>
    <div id="ipaddress"></div>
    <div id="trafficcount">Connections seen:</div>
    <div id="trafficsize">Traffic size:</div>
    <div id="lastseen">Last seen:</div>
</div>
<div id="mynetwork"></div>

<div id="output"></div>

<script language="javascript" type="text/javascript">

    var traffic_dataset = new vis.DataSet([]);
    var graph2d_1;
    var selectedNodeId;
    var traffic_ws;
    var info_ws;
    showGraph(traffic_dataset);

    //
    // WEBSOCKET CODE
    //
    var wsUri = "ws://localhost:12345/";
    var running = true;

    function init()
    {
        startWebSockets();
    }

    function startWebSockets()
    {
        traffic_ws = new WebSocket(wsUri, "traffic-data-protocol");
        traffic_ws.onopen = function(evt) { onTrafficOpen(evt) };
        traffic_ws.onclose = function(evt) { onTrafficClose(evt) };
        traffic_ws.onmessage = function(evt) { onTrafficMessage(evt) };
        traffic_ws.onerror = function(evt) { onTrafficError(evt) };

        info_ws = new WebSocket(wsUri, "info-protocol");
        info_ws.onmessage = function(evt) { onInfoMessage(evt) };
    }

    function onInfoMessage(evt) {
        var data_parts = evt.data.split(/\s+/);
        var type = data_parts[0];
        var request = data_parts[1];
        var response = data_parts.slice(2).join(" ");
        switch (type) {
            case 'arp2ip':
              var node = nodes.get(selectedNodeId);
              if (node && node.address == request) {
                writeToScreen("ipaddress", "IP(s): " + response);
              }
              break;
            case 'arp2dhcpname':
              var node = nodes.get(getNodeId(request));
              node.label = response;
              nodes.update(node);
              break
        }
    }

    function onTrafficOpen(evt)
    {
        //show connected status somewhere
    }

    function onTrafficClose(evt)
    {
        //show disconnected status somewhere
    }

    function onTrafficMessage(evt)
    {
        if (running) {
            //writeToScreen('<span style="color: blue;">RESPONSE: .' + evt.data+'.</span>');
            try {
                var data = JSON.parse(evt.data);
                var timestamp = data['timestamp']
                // update traffic view
                d = new Date(timestamp*1000);
                traffic_dataset.add({x: d, y: data['total_size'], group: 0});
                traffic_dataset.add({x: d, y: data['total_count'], group: 1});

                var options = {
                    start: new Date((timestamp*1000)-600000),
                    end: d,
                    height: '140px',
                    drawPoints: false,
                };
                graph2d_1.setOptions(options);
                ids = traffic_dataset.getIds();
                if (ids.length > 100) {
                    //traffic_dataset.remove(ids[0]);
                    //running = false;
                }

                //
                // update network view
                //

                // clean out old nodes, and reset color
                var now = Math.floor(Date.now() / 1000);
                var delete_before = now - 600;
                var unhighlight_before = now - 10;
                for (ip in nodeIds) {
                    var nodeId = getNodeId(ip)
                    node = nodes.get(nodeId);
                    if (node.lastseen < delete_before) {
                        // does this remove the edges as well?
                        delete nodeIds[ip];
                        nodes.remove(nodeId);
                        deleteEdges(nodeId);
                    } else if (node.lastseen < unhighlight_before  && node["color"] == 'red') {
                        node["color"] = 'lightblue';
                        nodes.update(node);
                    }
                }

                // Add the new flows
                var arr = data['flows'];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var f = arr[i];
                    addFlow(timestamp, f['from'], f['to'], f['count'], f['size']);
                }
            } catch (error) {
                alert(error + ": " + evt.data);
            }
            //traffic_ws.close();
        }
    }

    function onTrafficError(evt)
    {
        // todo: not here
        writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
    }

    function writeToScreen(element, message)
    {
        var el = document.getElementById(element);
        el.innerHTML = message;
    }

    window.addEventListener("load", init, false);


    //
    // Traffic total code
    //
    function showGraph(dataset) {
        var container = document.getElementById('visualization');

        //
        // Group options
        //
        var names = ['Traffic size', 'Packet count'];
        var groups = new vis.DataSet();
        groups.add({
        id: 0,
        content: names[0],
        options: {
            shaded: {
                orientation: 'bottom' // top, bottom
            }
        }});

        groups.add({
            id: 1,
            content: names[1],
            options: {
                shaded: {
                    orientation: 'bottom' // top, bottom
                },
                yAxisOrientation: 'right'
            }});

        // Graph options
        var options = {
            //start: '2017-01-26',
            //end: '2017-01-28',
            height: '140px',
            drawPoints: false,
        };

        graph2d_1 = new vis.Graph2d(container, dataset, groups, options);
    }

    //
    // Network view code
    //

   var nodeIds, shadowState, nodesArray, nodes, edgesArray, edges, network, curNodeId, curEdgeId;

    function startNetwork() {
        // mapping from ip to nodeId
        nodeIds = {};

        shadowState = false;

        // start counting with one (is this internally handled?)
        curNodeId = 1;
        curEdgeId = 1;

        // create an array with nodes
        nodesArray = [
        ];
        nodes = new vis.DataSet(nodesArray);

        // create an array with edges
        edgesArray = [
        ];
        edges = new vis.DataSet(edgesArray);

        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        network = new vis.Network(container, data, options);
        network.on("selectNode", nodeSelected);
    }

    function updateNodeInfo(nodeId) {
        node = nodes.get(nodeId);
        writeToScreen("selected", "Selected: " + node.label);
        writeToScreen("trafficsize", "Connections seen: " + node.count);
        writeToScreen("trafficcount", "Traffic size: " + node.size);
        writeToScreen("ipaddress", "");
        writeToScreen("lastseen", "Last seen: " + new Date(node.lastseen*1000));
        // TODO: mark that this is hw not ip
        info_ws.send("arp2ip " + node.address);
    }

    function nodeSelected(event) {
        var nodeId = event.nodes[0];
        if (typeof(nodeId) == 'number' && selectedNodeId != nodeId) {
            updateNodeInfo(nodeId);
            selectedNodeId = nodeId;
        }
    }

    function resetAllNodes() {
        nodes.clear();
        edges.clear();
        nodes.add(nodesArray);
        edges.add(edgesArray);
    }

    function resetAllNodesStabilize() {
        resetAllNodes();
        network.stabilize();
    }

    function setTheData() {
        nodes = new vis.DataSet(nodesArray);
        edges = new vis.DataSet(edgesArray);
        network.setData({nodes:nodes, edges:edges})
    }

    function resetAll() {
        if (network !== null) {
            network.destroy();
            network = null;
        }
        startNetwork();
    }

    function haveNode(ip) {
        return (ip in nodeIds);
    }

    function getNodeId(ip) {
        if (ip in nodeIds) {
            return nodeIds[ip];
        } else {
            return null;
        }
    }

    function alertWithObject(m, o) {
        str = m + "\n";
        for(var propertyName in o) {
           // propertyName is what you want
           // you can get the value like this: myObject[propertyName]
           str += propertyName + ": " + o[propertyName] + "\n";
        }
        alert(str);
    }

    function addNode(timestamp, ip, scale, count, size, lwith) {
        var existing = getNodeId(ip);
        if (existing) {
            var node = nodes.get(existing)
            //alert("node: " + node + " color: " + node['color'] + " size: " + node.size);
            // Set the color to mark 'recent'

            node["size"] += size;
            node["count"] += size;
            node["lastseen"] = timestamp;

            if (scale) {
                node["color"] = 'red';
                node["value"] = node["value"] + size;
            }
            nodes.update(node);
        } else {
            var c;
            if (scale) {
                c = 'red';
            } else {
                c = 'gray';
            }
            nodeIds[ip] = curNodeId;
            nodes.add({id:curNodeId,
                       address: ip, // (note: this can also be mac addr)
                       label: ip,
                       color: c,
                       value: size,
                       count: count,
                       size: size,
                       lastseen: timestamp,
                       scaling:{
                           min: 1,
                           label: {
                               enabled: true
                           }
                       }
                    });
            curNodeId += 1;
            info_ws.send("arp2dhcpname " + ip)
        }
        if (selectedNodeId && selectedNodeId == existing) {
            updateNodeInfo(selectedNodeId);
        }
    }

    function addEdge(from, to) {
        var fromNodeId = nodeIds[from];
        var toNodeId = nodeIds[to];
        var existing = edges.get({
            filter: function(item) {
                return (item.from == fromNodeId && item.to == toNodeId);
            }
        });
        if (existing.length == 0) {
            edges.add({id: curEdgeId, from: fromNodeId, to: toNodeId, color: 'blue'});
            curEdgeId += 1;
        }
    }

    function deleteEdges(nodeId) {
        var toDelete = edges.get({
            filter: function (item) {
                return (item.from == nodeId || item.to == nodeId);
            }
        });
        for (var i=0; i < toDelete.length; i++) {
            var edge = toDelete[i];
            var e = edges.get(edge);
            edges.remove(edge.id);
        }
    }

    function addFlow(timestamp, from, to, count, size) {
        addNode(timestamp, from, false, count, size, "to " + to);
        addNode(timestamp, to, true, count, size, "from " + from);
        addEdge(from, to);
        network.fit({ duration: 500 } );
    }

    startNetwork();

</script>
</body>
</html>
