<!DOCTYPE HTML>
<html>
<head>
    <script src="./js/jquery-3.1.1.min.js"></script>

    <script src="./js/jquery-ui-1.12.1.custom/jquery-ui.min.js"></script>
    <link href="./js/jquery-ui-1.12.1.custom/jquery-ui.theme.css" rel="stylesheet" type="text/css" />
    <link href="./js/jquery-ui-1.12.1.custom/jquery-ui.css" rel="stylesheet" type="text/css" />

    <script src="./js/vis-4.18.0/dist/vis.js"></script>
    <link href="./js/vis-4.18.0/dist/vis.min.css" rel="stylesheet" type="text/css" />

    <meta charset="utf-8">
    <title>Websocket client</title>

    <style type="text/css">
        html, body
        {
            height: 100%;
            font-family: Arial, Helvetica, sans-serif;
        }
        body
        {
            display: flex;
            flex-direction: column;
        }
        #visualization
        {
            height: 140px;
        }
        #infobar
        {
            background: white;
        }
        #mynetwork
        {
            flex:1;
            border: 1px solid lightgray;
        }

        #nodeinfo-data {
            padding: 10px;
            spacing: 6px;
        }
        #title { float: left; }
        #status {
            background-color: ffcccc;
            //position: absolute;
            border: 1px solid black;
            //top: 20px;
            //right: 80px;
            float:right;
            padding: 4px;
        }
        #filter-list-button { float: right; spacing: 10px;}
        #filter-list .ui-selecting { background: #FECA40; }
        #filter-list .ui-selected { background: #F39814; color: white; }
        #filter-list {
            list-style-type: none; margin: 0; padding: 0;
        }

        #filter-list li {
            margin: 3px; padding: 0.4em; 
        }
    </style>
</head>
<body>




<div id="buttonbar">
  <div id="title"><h2>SPIN traffic data prototype</h2></div>
  <div id="status" class="ui-corner-all">Not connected</div>
  <button id="filter-list-button">Show filter list</button>
</div>

<div id="visualization" class="ui-widget-content ui-corner-all"></div>

<div id="mynetwork" class="ui-corner-all"></div>


<!-- dialogs -->

<div id="ignore-dialog" title="Ignore this node?">
  <p><span class="ui-icon ui-icon-alert" style="float:left; margin:12px 12px 20px 0;"></span>Right now there is no easy way to unignore. Are you sure?</p>
</div>

<div id="rename-dialog" title="Rename node">
  <form>
    <fieldset>
      <label for="rename-field">New node name</label>
      <input type="text" name="rename-field" id="rename-field" value="" class="text ui-widget-content ui-corner-all">
 
      <!-- Allow form submission with keyboard without duplicating the dialog button -->
      <input type="submit" tabindex="-1" style="position:absolute; top:-1000px">
    </fieldset>
  </form>
</div>

<div id="nodeinfo" title="Basic dialog">
    <div>
        <div id="options">
            <button id="ignore-node-button" class="">Ignore this node</button>
            <button id="rename-node-button" class="">Rename this node</button>
        </div>
        <div id="nodeinfo-data" class="ui-widget-content ui-corner-all">
            <div id="trafficcount">Connections seen:</div>
            <div id="trafficsize">Traffic size:</div>
            <div id="lastseen">Last seen:</div>
            <div id="ipaddress">IP Address(es)</div>
            <div id="reversedns">Reverse DNS:</div>
            <div id="netowner">Network owner:</div>
        </div>
    </div>
</div>

<div id="filter-list-dialog" title="Filter list">
    <ul id="filter-list">
    </ul>
</div>

<!-- end of dialogs -->

<script type="text/javascript">

    var traffic_dataset = new vis.DataSet([]);
    var graph2d_1;
    var selectedNodeId;
    var traffic_ws;
    
    // mapping of node names
    var nodeNames = {}
    // list of filters
    var filterList = [];
    // feed this data from websocket command
    //nodeNames["9c:eb:e8:0c:b7:7b"] = "kweenie";
    //nodeNames["ac:22:0b:9b:74:41"] = "kweenie2";

    showGraph(traffic_dataset);

    var sidebar_visible = false;

    $("#ignore-dialog").hide();
    $("#rename-dialog").hide();

    $( "#nodeinfo" ).dialog({
      autoOpen: false,
      position: { my: "left top", at: "left top", of: "#mynetwork" }
    });
    
    //
    // code to ignore nodes
    // 
    function ignoreNode(nodeId) {
        var node = nodes.get(nodeId);

        sendCommand("add_ignore", node.address);

        // should we remove it now?
    }

    //
    // Create the ignore node dialog
    //
    $( function() {
        var dialog;
        
        dialog = $( "#ignore-dialog" ).dialog({
          autoOpen: false,
          resizable: false,
          height: "auto",
          width: 400,
          modal: true,
          buttons: {
            "Ignore node": function() {
              ignoreNode(selectedNodeId);
              $( this ).dialog( "close" );
            },
            Cancel: function() {
              $( this ).dialog( "close" );
            }
          }
        });
        $( "#ignore-node-button" ).button().on( "click", function() {
          dialog.dialog( "open" );
        });
    } );

    //
    // Code for the rename dialog
    //
    $( function() {
        var name = $( "#rename-field" );
        var dialog;
        var allFields = $( [] ).add( name );
        
        function renameNode() {
            var argument = {};
            var node = nodes.get(selectedNodeId);
            var newname = name.val();
            argument['address'] = node.address;
            argument['name'] = newname;
            sendCommand("add_name", argument);

            node.label = newname;
            nodes.update(node);
        }

        dialog = $( "#rename-dialog" ).dialog({
          autoOpen: false,
          width: 380,
          modal: true,
          buttons: {
            "Rename node": submitted,
            Cancel: function() {
              dialog.dialog( "close" );
            }
          },
          close: function() {
            form[ 0 ].reset();
            allFields.removeClass( "ui-state-error" );
          }
        });

        function submitted() {
          renameNode();
          dialog.dialog("close");
        }
        
        form = dialog.find( "form" ).on( "submit", function( event ) {
          event.preventDefault();
          submitted();
        });
     
        $( "#rename-node-button" ).button().on( "click", function() {
            dialog.dialog( "open" );
        });
    } );

    //
    // Filter list dialog
    //
    $( function() {
      $( "#filter-list" ).selectable({
        stop: function() {
          var selected = [];
          $(".ui-dialog-buttonpane button:contains('Remove Filters')").button("disable");
          $( ".ui-selected", this ).each(function() {
            selected.push(index);
            var index = $( "#filter-list li" ).index( this );
          });
          if (selected.length > 0) {
            $(".ui-dialog-buttonpane button:contains('Remove Filters')").button("enable");
          }
        }
      });
    } );

    $( function() {
        var dialog;
        var selected;
        
        dialog = $( "#filter-list-dialog" ).dialog({
          autoOpen: false,
          autoResize:true,
          resizable: true,
          modal: false,
          buttons: {
            "Remove Filters": function() {
              $( "#filter-list .ui-selected", this ).each(function() {
                  // The inner text contains the name of the filter
                  sendCommand("remove_ignore", this.innerText);
              });
            },
            Cancel: function() {
              dialog.dialog( "close" );
            }
          },
          close: function() {
          }
        });

        $(".ui-dialog-buttonpane button:contains('Remove Filters')").button("disable");
        $( "#filter-list-button" ).button().on( "click", function() {
            dialog.dialog( "open" );
        });
    } );

    function updateFilterList() {
        $("#filter-list").empty();
        for (var i=0; i<filterList.length; i++) {
            var li = $("<li class='ui-widget-content'></li> ").text(filterList[i]);
            $("#filter-list").append(li);
        }
    }



    //
    // WEBSOCKET CODE
    //
    var running = true;

    function createWebSocketUri() {
        var protocolPrefix = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
        var host = (window.location.host === '') ? '192.168.8.1' : window.location.host
        return protocolPrefix + '//' + host + ":12345/";
    }

    function init()
    {
        startWebSockets();
    }

    function startWebSockets()
    {
        traffic_ws = new WebSocket(createWebSocketUri(), "traffic-data-protocol");
        traffic_ws.onopen = function(evt) { onTrafficOpen(evt) };
        traffic_ws.onclose = function(evt) { onTrafficClose(evt) };
        traffic_ws.onmessage = function(evt) { onTrafficMessage(evt) };
        traffic_ws.onerror = function(evt) { onTrafficError(evt) };
    }

    function onTrafficMessage(evt) {
        try {
            var message = JSON.parse(evt.data)
            var command = message['command'];
            var argument = message['argument'];
            var result = message['result'];
            switch (command) {
                case 'arp2ip':
                  var node = nodes.get(selectedNodeId);
                  if (node && node.address == argument) {
                    writeToScreen("ipaddress", "IP(s): " + result);
                  }
                  break;
                case 'ip2hostname':
                  var node = nodes.get(selectedNodeId);
                  if (node && node.address == argument) {
                    writeToScreen("reversedns", "Reverse DNS: " + result);
                  }
                  break;
                case 'ip2netowner':
                  var node = nodes.get(selectedNodeId);
                  if (node && node.address == argument) {
                    writeToScreen("netowner", "Network owner: " + result);
                  }
                  break;
                // this one should be obsolete
                /*case 'arp2dhcpname':
                  if (result && result != "") {
                      var node = nodes.get(getNodeId(argument));
                      node.label = result;
                      nodes.update(node);
                  }
                  break;*/
                case 'traffic':
                  handleTrafficMessage(result);
                  break;
                case 'names':
                  nodeNames = result;
                  break;
                case 'ignore':
                  filterList = result;
                  updateFilterList();
                  break;
                default:
                  alert("unknown message from server: '" + command + "' with argument: '"+argument+"' and data: " + result)
                  break;
            }
        } catch (error) {
            alert(error + ": " + evt.data);
        }
    }

    function onTrafficOpen(evt)
    {
        //show connected status somewhere
        $("#status").css("background-color", "#ccffcc").text("Connected");
    }

    function onTrafficClose(evt)
    {
        //show disconnected status somewhere
        $("#status").css("background-color", "#ffcccc").text("Not connected");
    }

    function handleTrafficMessage(data) {
            var timestamp = data['timestamp']
            // update traffic view
            d = new Date(timestamp*1000);
            traffic_dataset.add({x: d, y: data['total_size'], group: 0});
            traffic_dataset.add({x: d, y: data['total_count'], group: 1});

            var options = {
                start: new Date((timestamp*1000)-600000),
                end: d,
                height: '140px',
                drawPoints: false,
            };
            graph2d_1.setOptions(options);
            ids = traffic_dataset.getIds();
            if (ids.length > 100) {
                //traffic_dataset.remove(ids[0]);
                //running = false;
            }

            //
            // update network view
            //

            // clean out old nodes, and reset color
            var now = Math.floor(Date.now() / 1000);
            var delete_before = now - 600;
            var unhighlight_before = now - 10;
            for (ip in nodeIds) {
                var nodeId = getNodeId(ip)
                var node = nodes.get(nodeId);
                if (node.lastseen < delete_before) {
                    // does this remove the edges as well?
                    delete nodeIds[ip];
                    nodes.remove(nodeId);
                    deleteEdges(nodeId);
                } else if (node.lastseen < unhighlight_before  && node["color"] == 'red') {
                    node["color"] = 'lightblue';
                    nodes.update(node);
                }
            }

            // Add the new flows
            var arr = data['flows'];
            for (var i = 0, len = arr.length; i < len; i++) {
                var f = arr[i];
                addFlow(timestamp, f['from'], f['to'], f['count'], f['size']);
            }
    }

    /*
    function onTrafficMessage(evt)
    {
        if (running) {
            //writeToScreen('<span style="color: blue;">RESPONSE: .' + evt.data+'.</span>');
            var message = JSON.parse(evt.data);
            if (message["command"] == "traffic") {
                handleTrafficMessage(message["result"]);
            }
        }
    }
    */

    function onTrafficError(evt)
    {
        // todo: not here
        writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
    }

    function writeToScreen(element, message)
    {
        var el = document.getElementById(element);
        el.innerHTML = message;
    }

    window.addEventListener("load", init, false);


    //
    // Traffic total code
    //
    function showGraph(dataset) {
        var container = document.getElementById('visualization');

        //
        // Group options
        //
        var names = ['Traffic size', 'Packet count'];
        var groups = new vis.DataSet();
        groups.add({
        id: 0,
        content: names[0],
        options: {
            shaded: {
                orientation: 'bottom' // top, bottom
            }
        }});

        groups.add({
            id: 1,
            content: names[1],
            options: {
                shaded: {
                    orientation: 'bottom' // top, bottom
                },
                yAxisOrientation: 'right'
            }});

        // Graph options
        var options = {
            //start: '2017-01-26',
            //end: '2017-01-28',
            height: '140px',
            drawPoints: false,
        };

        graph2d_1 = new vis.Graph2d(container, dataset, groups, options);
    }

    //
    // Network view code
    //

   var nodeIds, shadowState, nodesArray, nodes, edgesArray, edges, network, curNodeId, curEdgeId;

    function startNetwork() {
        // mapping from ip to nodeId
        nodeIds = {};

        shadowState = false;

        // start counting with one (is this internally handled?)
        curNodeId = 1;
        curEdgeId = 1;

        // create an array with nodes
        nodesArray = [
        ];
        nodes = new vis.DataSet(nodesArray);

        // create an array with edges
        edgesArray = [
        ];
        edges = new vis.DataSet(edgesArray);

        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        network = new vis.Network(container, data, options);
        network.on("selectNode", nodeSelected);
    }

    function updateNodeInfo(nodeId) {
        var node = nodes.get(nodeId);
        //writeToScreen("infotitle", node.label);
        writeToScreen("trafficsize", "Connections seen: " + node.count);
        writeToScreen("trafficcount", "Traffic size: " + node.size);
        writeToScreen("ipaddress", "");
        writeToScreen("lastseen", "Last seen: " + new Date(node.lastseen*1000));
        // TODO: mark that this is hw not ip
        return node;
    }

    function sendCommand(command, argument) {
        cmd = {}
        cmd['command'] = command;
        cmd['argument'] = argument;
        traffic_ws.send(JSON.stringify(cmd));
    }

    function nodeSelected(event) {
        var nodeId = event.nodes[0];
        if (typeof(nodeId) == 'number' && selectedNodeId != nodeId) {
            node = updateNodeInfo(nodeId);
            selectedNodeId = nodeId;
            sendCommand("arp2ip", node.address);
            writeToScreen("reversedns", "Reverse DNS: &lt;searching&gt;");
            sendCommand("ip2hostname", node.address);
            writeToScreen("netowner", "Network owner: &lt;searching&gt;");
            sendCommand("ip2netowner", node.address);
            $("#nodeinfo").dialog('option','title', node.label);
            $("#nodeinfo").dialog('open');
        }
        
    }

    function resetAllNodes() {
        nodes.clear();
        edges.clear();
        nodes.add(nodesArray);
        edges.add(edgesArray);
    }

    function resetAllNodesStabilize() {
        resetAllNodes();
        network.stabilize();
    }

    function setTheData() {
        nodes = new vis.DataSet(nodesArray);
        edges = new vis.DataSet(edgesArray);
        network.setData({nodes:nodes, edges:edges})
    }

    function resetAll() {
        if (network !== null) {
            network.destroy();
            network = null;
        }
        startNetwork();
    }

    function haveNode(ip) {
        return (ip in nodeIds);
    }

    function getNodeId(ip) {
        var nodeName = ip;
        if (ip in nodeNames) {
            nodeName = nodeNames[ip];
        }
        if (ip in nodeIds) {
            return nodeIds[ip];
        } else {
            return null;
        }
    }

    function alertWithObject(m, o) {
        str = m + "\n";
        for(var propertyName in o) {
           // propertyName is what you want
           // you can get the value like this: myObject[propertyName]
           str += propertyName + ": " + o[propertyName] + "\n";
        }
        alert(str);
    }

    function addNode(timestamp, ip, scale, count, size, lwith) {
        var existing = getNodeId(ip);
        // By default, the ip/mac is the node name, but if
        // it is present in the user-set nodeNames dict, use that
        if (existing) {
            var node = nodes.get(existing)
            //alert("node: " + node + " color: " + node['color'] + " size: " + node.size);
            // Set the color to mark 'recent'

            node["size"] += size;
            node["count"] += size;
            node["lastseen"] = timestamp;

            if (scale) {
                node["color"] = 'red';
                node["value"] = node["value"] + size;
            }
            nodes.update(node);
        } else {
            var nodeName = ip;
            if (ip in nodeNames) {
                nodeName = nodeNames[ip];
            }
            var c;
            if (scale) {
                c = 'red';
            } else {
                c = 'gray';
            }
            nodeIds[ip] = curNodeId;
            nodes.add({id:curNodeId,
                       address: ip, // (note: this can also be mac addr)
                       label: nodeName,
                       color: c,
                       value: size,
                       count: count,
                       size: size,
                       lastseen: timestamp,
                       scaling:{
                           min: 1,
                           label: {
                               enabled: true
                           }
                       }
                    });
            curNodeId += 1;
            //sendCommand("arp2dhcpname", ip)
        }
        if (selectedNodeId && selectedNodeId == existing) {
            updateNodeInfo(selectedNodeId);
        }
    }

    function addEdge(from, to) {
        var fromNodeId = nodeIds[from];
        var toNodeId = nodeIds[to];
        var existing = edges.get({
            filter: function(item) {
                return (item.from == fromNodeId && item.to == toNodeId);
            }
        });
        if (existing.length == 0) {
            edges.add({id: curEdgeId, from: fromNodeId, to: toNodeId, color: 'blue'});
            curEdgeId += 1;
        }
    }

    function deleteEdges(nodeId) {
        var toDelete = edges.get({
            filter: function (item) {
                return (item.from == nodeId || item.to == nodeId);
            }
        });
        for (var i=0; i < toDelete.length; i++) {
            var edge = toDelete[i];
            var e = edges.get(edge);
            edges.remove(edge.id);
        }
    }

    function addFlow(timestamp, from, to, count, size) {
        addNode(timestamp, from, false, count, size, "to " + to);
        addNode(timestamp, to, true, count, size, "from " + from);
        addEdge(from, to);
        network.fit({ duration: 500 } );
    }

    startNetwork();

</script>
</body>
</html>
