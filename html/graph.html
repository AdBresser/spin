<!DOCTYPE HTML>
<html>
<head>
    <script src="./vis-4.18.0/dist/vis.js"></script>
    <link href="./vis-4.18.0/dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Websocket client</title>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 600px;
            border: 1px solid lightgray;
        }

        p {
            max-width:600px;
        }

        h4 {
            margin-bottom:3px;
        }
    </style>
</head>
<body>

<h2>WebSocket test</h2>

<div id="visualization"></div>

<div id="mynetwork"></div>

<div>datalog:</div>

<div id="output"></div>

<script language="javascript" type="text/javascript">

    var traffic_dataset = new vis.DataSet([]);
    var graph2d_1;
    showGraph(traffic_dataset);

    //
    // WEBSOCKET CODE
    //
    var wsUri = "ws://localhost:12345/";
    var output;
    var running = true;

    function init()
    {
        output = document.getElementById("output");
        testWebSocket();
    }

    function testWebSocket()
    {
        websocket = new WebSocket(wsUri, "dumb-increment-protocol");
        websocket.onopen = function(evt) { onOpen(evt) };
        websocket.onclose = function(evt) { onClose(evt) };
        websocket.onmessage = function(evt) { onMessage(evt) };
        websocket.onerror = function(evt) { onError(evt) };
    }

    function onOpen(evt)
    {
        writeToScreen("CONNECTED");
        //doSend("WebSocket rocks");
    }

    function onClose(evt)
    {
        writeToScreen("DISCONNECTED");
    }

    function onMessage(evt)
    {
        if (running) {
            //writeToScreen('<span style="color: blue;">RESPONSE: .' + evt.data+'.</span>');
            try {
                data = JSON.parse(evt.data);

                // update traffic view
                d = new Date(data['timestamp']*1000);
                traffic_dataset.add({x: d, y: data['total_size'], group: 0});
                traffic_dataset.add({x: d, y: data['total_count'], group: 1});

                var options = {
                    start: new Date((data['timestamp']*1000)-600000),
                    end: d,
                    height: '140px',
                    drawPoints: false,
                };
                graph2d_1.setOptions(options);
                ids = traffic_dataset.getIds();
                if (ids.length > 100) {
                    //traffic_dataset.remove(ids[0]);
                    //running = false;
                }

                // update network view
                var arr = data['flows'];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var f = arr[i];
                    addFlow(f['from'], f['to']);
                }
            } catch (error) {
                alert(error + ": " + evt.data);
            }
            //websocket.close();
        }
    }

    function onError(evt)
    {
        writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
    }

    function doSend(message)
    {
        writeToScreen("SENT: " + message);
        websocket.send(message);
    }

    function writeToScreen(message)
    {
        var pre = document.createElement("p");
        pre.style.wordWrap = "break-word";
        pre.innerHTML = message;
        output.appendChild(pre);
    }

    window.addEventListener("load", init, false);


    //
    // Traffic total code
    //
    function showGraph(dataset) {
        var container = document.getElementById('visualization');

        //
        // Group options
        //
        var names = ['Traffic size', 'Packet count'];
        var groups = new vis.DataSet();
        groups.add({
        id: 0,
        content: names[0],
        options: {
            shaded: {
                orientation: 'bottom' // top, bottom
            }
        }});

        groups.add({
            id: 1,
            content: names[1],
            options: {
                shaded: {
                    orientation: 'bottom' // top, bottom
                },
                yAxisOrientation: 'right'
            }});

        // Graph options
        var options = {
            //start: '2017-01-26',
            //end: '2017-01-28',
            height: '140px',
            drawPoints: false,
        };

        graph2d_1 = new vis.Graph2d(container, dataset, groups, options);
    }

    //
    // Network view code
    //

   var nodeIds, shadowState, nodesArray, nodes, edgesArray, edges, network, curNodeId, curEdgeId;

    function startNetwork() {
        // mapping from ip to nodeId
        nodeIds = {};
        // mapping from ip+ip to edgeId
        edgeIds = {};

        shadowState = false;

        // start counting with one (is this internally handled?)
        curNodeId = 1;
        curEdgeId = 1;

        // create an array with nodes
        nodesArray = [
        ];
        nodes = new vis.DataSet(nodesArray);

        // create an array with edges
        edgesArray = [
        ];
        edges = new vis.DataSet(edgesArray);

        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        network = new vis.Network(container, data, options);
    }

    //function addNode() {
    //    var newId = (Math.random() * 1e7).toString(32);
    //    nodes.add({id:newId, label:"I'm new!"});
    //    nodeIds.push(newId);
    //}

    function changeNode1() {
        var newColor = '#' + Math.floor((Math.random() * 255 * 255 * 255)).toString(16);
        nodes.update([{id:1, color:{background:newColor}}]);
    }

    function removeRandomNode() {
        var randomNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)];
        nodes.remove({id:randomNodeId});

        var index = nodeIds.indexOf(randomNodeId);
        nodeIds.splice(index,1);
    }

    function changeOptions() {
        shadowState = !shadowState;
        network.setOptions({nodes:{shadow:shadowState},edges:{shadow:shadowState}});
    }

    function resetAllNodes() {
        nodes.clear();
        edges.clear();
        nodes.add(nodesArray);
        edges.add(edgesArray);
    }

    function resetAllNodesStabilize() {
        resetAllNodes();
        network.stabilize();
    }

    function setTheData() {
        nodes = new vis.DataSet(nodesArray);
        edges = new vis.DataSet(edgesArray);
        network.setData({nodes:nodes, edges:edges})
    }

    function resetAll() {
        if (network !== null) {
            network.destroy();
            network = null;
        }
        startNetwork();
    }

    function haveNode(ip) {
        return (ip in nodeIds);
    }

    function getNodeId(ip) {
        if (ip in nodeIds) {
            return nodeIds[ip];
        } else {
            return null;
        }
    }

    function addNode(ip) {
        existing = getNodeId(ip);
        if (haveNode(ip)) {
            // er, do nothing?
        } else {
            nodeIds[ip] = curNodeId;
            nodes.add({id:curNodeId, label:ip});
            curNodeId += 1;
        }
    }

    function haveEdge(from, to) {
        return (from + "-" + to in edgeIds) || (to + "-" + from in edgeIds);
    }

    function addEdge(from, to) {
        if (haveEdge(from, to)) {
            // do nothing
        } else {
            edgeIds[from + "-" + to] = curEdgeId;
            fromNodeId = nodeIds[from];
            toNodeId = nodeIds[to];
            edges.add({id: curEdgeId, from: fromNodeId, to: toNodeId});
            curEdgeId += 1;
        }
    }

    function addFlow(from, to) {
        addNode(from);
        addNode(to);
        addEdge(from, to);
    }

    startNetwork();

</script>
</body>
</html>
