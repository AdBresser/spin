<!DOCTYPE HTML>
<html>
<head>
    <script src="./vis-4.18.0/dist/vis.js"></script>
    <link href="./vis-4.18.0/dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Websocket client</title>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 600px;
            border: 1px solid lightgray;
        }

        p {
            max-width:600px;
        }

        h4 {
            margin-bottom:3px;
        }
        #infobar {
            border: 1px solid lightgray;
        }
    </style>
</head>
<body>

<h2>SPIN traffic data prototype</h2>

<div id="visualization"></div>
<div id="infobar">
    <div id="ipaddress">IP Address:</div>
    <div id="trafficcount">Connections seen:</div>
    <div id="trafficsize">Traffic size:</div>
    <div id="macaddress"/>
</div>
<div id="mynetwork"></div>

<div id="output"></div>

<script language="javascript" type="text/javascript">

    var traffic_dataset = new vis.DataSet([]);
    var graph2d_1;
    var selectedNodeId;
    showGraph(traffic_dataset);

    //
    // WEBSOCKET CODE
    //
    var wsUri = "ws://192.168.1.1:12345/";
    var running = true;

    function init()
    {
        testWebSocket();
    }

    function testWebSocket()
    {
        websocket = new WebSocket(wsUri, "dumb-increment-protocol");
        websocket.onopen = function(evt) { onOpen(evt) };
        websocket.onclose = function(evt) { onClose(evt) };
        websocket.onmessage = function(evt) { onMessage(evt) };
        websocket.onerror = function(evt) { onError(evt) };
    }

    function onOpen(evt)
    {
        //show connected status somewhere
    }

    function onClose(evt)
    {
        //show disconnected status somewhere
    }

    function onMessage(evt)
    {
        if (running) {
            //writeToScreen('<span style="color: blue;">RESPONSE: .' + evt.data+'.</span>');
            try {
                var data = JSON.parse(evt.data);
                var timestamp = data['timestamp']
                // update traffic view
                d = new Date(timestamp*1000);
                traffic_dataset.add({x: d, y: data['total_size'], group: 0});
                traffic_dataset.add({x: d, y: data['total_count'], group: 1});

                var options = {
                    start: new Date((timestamp*1000)-600000),
                    end: d,
                    height: '140px',
                    drawPoints: false,
                };
                graph2d_1.setOptions(options);
                ids = traffic_dataset.getIds();
                if (ids.length > 100) {
                    //traffic_dataset.remove(ids[0]);
                    //running = false;
                }

                //
                // update network view
                //

                // clean out old nodes, and reset color
                var now = Math.floor(Date.now() / 1000);
                var delete_before = now - 600;
                var unhighlight_before = now - 10;
                for (ip in nodeIds) {
                    var nodeId = getNodeId(ip)
                    node = nodes.get(nodeId);
                    if (node.lastseen < delete_before) {
                        // does this remove the edges as well?
                        delete nodeIds[ip];
                        nodes.remove(nodeId);
                    } else if (node.lastseen < unhighlight_before  && node["color"] == 'red') {
                        node["color"] = 'lightblue';
                        nodes.update(node);
                    }
                }

                // Add the new flows
                var arr = data['flows'];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var f = arr[i];
                    addFlow(timestamp, f['from'], f['to'], f['count'], f['size']);
                }
            } catch (error) {
                alert(error + ": " + evt.data);
            }
            //websocket.close();
        }
    }

    function onError(evt)
    {
        writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
    }

    function doSend(message)
    {
        writeToScreen("SENT: " + message);
        websocket.send(message);
    }

    function writeToScreen(element, message)
    {
        var el = document.getElementById(element);
        el.innerHTML = message;
    }

    window.addEventListener("load", init, false);


    //
    // Traffic total code
    //
    function showGraph(dataset) {
        var container = document.getElementById('visualization');

        //
        // Group options
        //
        var names = ['Traffic size', 'Packet count'];
        var groups = new vis.DataSet();
        groups.add({
        id: 0,
        content: names[0],
        options: {
            shaded: {
                orientation: 'bottom' // top, bottom
            }
        }});

        groups.add({
            id: 1,
            content: names[1],
            options: {
                shaded: {
                    orientation: 'bottom' // top, bottom
                },
                yAxisOrientation: 'right'
            }});

        // Graph options
        var options = {
            //start: '2017-01-26',
            //end: '2017-01-28',
            height: '140px',
            drawPoints: false,
        };

        graph2d_1 = new vis.Graph2d(container, dataset, groups, options);
    }

    //
    // Network view code
    //

   var nodeIds, shadowState, nodesArray, nodes, edgesArray, edges, network, curNodeId, curEdgeId;

    function startNetwork() {
        // mapping from ip to nodeId
        nodeIds = {};
        // mapping from ip+ip to edgeId
        edgeIds = {};

        shadowState = false;

        // start counting with one (is this internally handled?)
        curNodeId = 1;
        curEdgeId = 1;

        // create an array with nodes
        nodesArray = [
        ];
        nodes = new vis.DataSet(nodesArray);

        // create an array with edges
        edgesArray = [
        ];
        edges = new vis.DataSet(edgesArray);

        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        network = new vis.Network(container, data, options);
        network.on("selectNode", nodeSelected);
    }

    function updateNodeInfo(nodeId) {
        node = nodes.get(nodeId);
        writeToScreen("ipaddress", "IP Address: " + node.label);
        writeToScreen("trafficsize", "Connections seen: " + node.count);
        writeToScreen("trafficcount", "Traffic size: " + node.size);
        selectedNodeId = nodeId;
    }

    function nodeSelected(event) {
        var nodeId = event.nodes[0];
        if (typeof(nodeId) == 'number') {
            updateNodeInfo(nodeId);
        }
    }

    function resetAllNodes() {
        nodes.clear();
        edges.clear();
        nodes.add(nodesArray);
        edges.add(edgesArray);
    }

    function resetAllNodesStabilize() {
        resetAllNodes();
        network.stabilize();
    }

    function setTheData() {
        nodes = new vis.DataSet(nodesArray);
        edges = new vis.DataSet(edgesArray);
        network.setData({nodes:nodes, edges:edges})
    }

    function resetAll() {
        if (network !== null) {
            network.destroy();
            network = null;
        }
        startNetwork();
    }

    function haveNode(ip) {
        return (ip in nodeIds);
    }

    function getNodeId(ip) {
        if (ip in nodeIds) {
            return nodeIds[ip];
        } else {
            return null;
        }
    }

    function alertWithObject(o) {
        str = "Object:\n";
        for(var propertyName in o) {
           // propertyName is what you want
           // you can get the value like this: myObject[propertyName]
           str += propertyName + ": " + o[propertyName] + "\n";
        }
        alert(str);
    }

    function addNode(timestamp, ip, scale, count, size) {
        var existing = getNodeId(ip);
        if (existing) {
            var node = nodes.get(existing)
            //alert("node: " + node + " color: " + node['color'] + " size: " + node.size);
            // Set the color to mark 'recent'

            node["size"] += size;
            node["count"] += size;
            node["lastseen"] = timestamp;

            if (scale) {
                node["color"] = 'red';
                node["value"] = node["value"] + size;
            }
            nodes.update(node);
        } else {
            var c;
            if (scale) {
                c = 'red';
            } else {
                c = 'gray';
            }
            nodeIds[ip] = curNodeId;
            nodes.add({id:curNodeId,
                       label: ip,
                       color: c,
                       value: size,
                       count: count,
                       size: size,
                       lastseen: timestamp,
                       scaling:{
                           min: 1,
                           label: {
                               enabled: true
                           }
                       }
                    });
            curNodeId += 1;
        }
        if (selectedNodeId && selectedNodeId == existing) {
            updateNodeInfo(selectedNodeId);
        }
    }

    function haveEdge(from, to) {
        return (from + "-" + to in edgeIds) || (to + "-" + from in edgeIds);
    }

    function addEdge(from, to) {
        if (!haveEdge(from, to)) {
            edgeIds[from + "-" + to] = curEdgeId;
            fromNodeId = nodeIds[from];
            toNodeId = nodeIds[to];
            edges.add({id: curEdgeId, from: fromNodeId, to: toNodeId, color: 'blue'});
            curEdgeId += 1;
        }
    }

    function addFlow(timestamp, from, to, count, size) {
        addNode(timestamp, from, false, count, size);
        addNode(timestamp, to, true, count, size);
        addEdge(from, to);
    }

    startNetwork();

</script>
</body>
</html>
