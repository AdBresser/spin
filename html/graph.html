<!DOCTYPE HTML>
<html>
<head>
    <script src="./js/jquery-3.1.1.min.js"></script>

    <script src="./js/jquery-ui-1.12.1.custom/jquery-ui.min.js"></script>
    <link href="./js/jquery-ui-1.12.1.custom/jquery-ui.theme.css" rel="stylesheet" type="text/css" />

    <script src="./js/vis-4.18.0/dist/vis.js"></script>
    <link href="./js/vis-4.18.0/dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Websocket client</title>

    <style type="text/css">
        html, body
        {
            height: 100%;
        }
        body
        {
            display: flex;
            flex-direction: column;
        }
        #visualization
        {
            height: 140px;
        }
        #infobar
        {
            background: white;
        }
        #mynetwork
        {
            flex:1;
            border: 1px solid lightgray;
        }

        // don't put any visible elements in the toggler
        // they will remain after hide
        .toggler {
            display: none;
            width: 35%;
        }
        #infopanel {
            position: absolute;
            width: 35%;
            z-index: 100;
        }
        .panelclose {
            position: relative;
            top: 0px;
            right: 0px;
        }
        #pc {
            position: relative;
            top: 0px;
            right: 0px;
        }
    </style>
</head>
<body>

<h2>SPIN traffic data prototype</h2>

<div id="visualization" class="ui-widget-content ui-corner-all"></div>

<div class="toggler positionable" id="infopanel">
  <div id="effect" class="ui-widget-content ui-corner-all">
    <div id="infotitle" class="ui-widget-header ui-corner-all">Show</div>
    <div id="infoclose" class="panelclose ui-icon ui-icon-close positionable"></div>
    <div>
        
        <div id="trafficcount">Connections seen:</div>
        <div id="trafficsize">Traffic size:</div>
        <div id="lastseen">Last seen:</div>
        <div id="ipaddress">IP Address(es)</div>
        <div id="reversedns">Reverse DNS:</div>
        <div id="netowner">Network owner:</div>
        <div id="options">
            <!--todo <button class="">Ignore this node</button>-->
            <button class="">Name this node</button>
        </div>
    </div>
  </div>
</div>
<div id="mynetwork" class="ui-corner-all"></div>

<script language="javascript" type="text/javascript">

    var traffic_dataset = new vis.DataSet([]);
    var graph2d_1;
    var selectedNodeId;
    var traffic_ws;
    
    // mapping of node names
    nodeNames = {}
    // feed this data from websocket command
    //nodeNames["9c:eb:e8:0c:b7:7b"] = "kweenie";
    //nodeNames["ac:22:0b:9b:74:41"] = "kweenie2";

    showGraph(traffic_dataset);

    var sidebar_visible = false;

    function show_sidebar() {
        var options = {};
        var callback = null;
        if (!sidebar_visible) {
            $("#effect").show("slide", options, 500, callback);
            sidebar_visible=true;
        }
    }
    function hide_sidebar() {
        var options = {};
        var callback = null;
        if (sidebar_visible) {
            $("#effect").hide("slide", options, 500, callback);
            sidebar_visible=false;
        }
    }

    $( "#infotitle" ).position({
        of: $( "#infopanel" ),
        my: "right top",
        at: "right top"
    });
    $( "#infoclose" ).position({
        of: $( "#infopanel" ),
        my: "right top",
        at: "right top"
    }).click(hide_sidebar);
    $( "#infopanel" ).position({
        of: $( "#mynetwork" ),
        my: "left top",
        at: "left top"
    });
    $( "#effect" ).position({
        of: $( "#mynetwork" ),
        my: "left+10 top-40",
        at: "left+10 top-40"
    });
    $("#effect").hide();
    //show_sidebar();

    //
    // WEBSOCKET CODE
    //
    var running = true;

    function createWebSocketUri() {
        var protocolPrefix = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
        var host = (window.location.host === '') ? 'localhost' : window.location.host
        return protocolPrefix + '//' + host + ":12345/";
    }

    function init()
    {
        startWebSockets();
    }

    function startWebSockets()
    {
        traffic_ws = new WebSocket(createWebSocketUri(), "traffic-data-protocol");
        traffic_ws.onopen = function(evt) { onTrafficOpen(evt) };
        traffic_ws.onclose = function(evt) { onTrafficClose(evt) };
        traffic_ws.onmessage = function(evt) { onTrafficMessage(evt) };
        traffic_ws.onerror = function(evt) { onTrafficError(evt) };
    }

    function onTrafficMessage(evt) {
        var message = JSON.parse(evt.data)
        var command = message['command'];
        var argument = message['argument'];
        var result = message['result'];
        switch (command) {
            case 'arp2ip':
              var node = nodes.get(selectedNodeId);
              if (node && node.address == argument) {
                writeToScreen("ipaddress", "IP(s): " + result);
              }
              break;
            case 'ip2hostname':
              var node = nodes.get(selectedNodeId);
              if (node && node.address == argument) {
                writeToScreen("reversedns", "Reverse DNS: " + result);
              }
              break;
            case 'ip2netowner':
              var node = nodes.get(selectedNodeId);
              if (node && node.address == argument) {
                writeToScreen("netowner", "Network owner: " + result);
              }
              break;
            case 'arp2dhcpname':
              var node = nodes.get(getNodeId(argument));
              node.label = result;
              nodes.update(node);
              break;
            case 'traffic':
              handleTrafficMessage(result);
              break;
        }
    }

    function onTrafficOpen(evt)
    {
        //show connected status somewhere
    }

    function onTrafficClose(evt)
    {
        //show disconnected status somewhere
    }

    function handleTrafficMessage(data) {
        try {
            var timestamp = data['timestamp']
            // update traffic view
            d = new Date(timestamp*1000);
            traffic_dataset.add({x: d, y: data['total_size'], group: 0});
            traffic_dataset.add({x: d, y: data['total_count'], group: 1});

            var options = {
                start: new Date((timestamp*1000)-600000),
                end: d,
                height: '140px',
                drawPoints: false,
            };
            graph2d_1.setOptions(options);
            ids = traffic_dataset.getIds();
            if (ids.length > 100) {
                //traffic_dataset.remove(ids[0]);
                //running = false;
            }

            //
            // update network view
            //

            // clean out old nodes, and reset color
            var now = Math.floor(Date.now() / 1000);
            var delete_before = now - 600;
            var unhighlight_before = now - 10;
            for (ip in nodeIds) {
                var nodeId = getNodeId(ip)
                node = nodes.get(nodeId);
                if (node.lastseen < delete_before) {
                    // does this remove the edges as well?
                    delete nodeIds[ip];
                    nodes.remove(nodeId);
                    deleteEdges(nodeId);
                } else if (node.lastseen < unhighlight_before  && node["color"] == 'red') {
                    node["color"] = 'lightblue';
                    nodes.update(node);
                }
            }

            // Add the new flows
            var arr = data['flows'];
            for (var i = 0, len = arr.length; i < len; i++) {
                var f = arr[i];
                addFlow(timestamp, f['from'], f['to'], f['count'], f['size']);
            }
        } catch (error) {
            alert(error + ": " + evt.data);
        }
    }

    /*
    function onTrafficMessage(evt)
    {
        if (running) {
            //writeToScreen('<span style="color: blue;">RESPONSE: .' + evt.data+'.</span>');
            var message = JSON.parse(evt.data);
            if (message["command"] == "traffic") {
                handleTrafficMessage(message["result"]);
            }
        }
    }
    */

    function onTrafficError(evt)
    {
        // todo: not here
        writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
    }

    function writeToScreen(element, message)
    {
        var el = document.getElementById(element);
        el.innerHTML = message;
    }

    window.addEventListener("load", init, false);


    //
    // Traffic total code
    //
    function showGraph(dataset) {
        var container = document.getElementById('visualization');

        //
        // Group options
        //
        var names = ['Traffic size', 'Packet count'];
        var groups = new vis.DataSet();
        groups.add({
        id: 0,
        content: names[0],
        options: {
            shaded: {
                orientation: 'bottom' // top, bottom
            }
        }});

        groups.add({
            id: 1,
            content: names[1],
            options: {
                shaded: {
                    orientation: 'bottom' // top, bottom
                },
                yAxisOrientation: 'right'
            }});

        // Graph options
        var options = {
            //start: '2017-01-26',
            //end: '2017-01-28',
            height: '140px',
            drawPoints: false,
        };

        graph2d_1 = new vis.Graph2d(container, dataset, groups, options);
    }

    //
    // Network view code
    //

   var nodeIds, shadowState, nodesArray, nodes, edgesArray, edges, network, curNodeId, curEdgeId;

    function startNetwork() {
        // mapping from ip to nodeId
        nodeIds = {};

        shadowState = false;

        // start counting with one (is this internally handled?)
        curNodeId = 1;
        curEdgeId = 1;

        // create an array with nodes
        nodesArray = [
        ];
        nodes = new vis.DataSet(nodesArray);

        // create an array with edges
        edgesArray = [
        ];
        edges = new vis.DataSet(edgesArray);

        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {};
        network = new vis.Network(container, data, options);
        network.on("selectNode", nodeSelected);
    }

    function updateNodeInfo(nodeId) {
        node = nodes.get(nodeId);
        writeToScreen("infotitle", node.label);
        writeToScreen("trafficsize", "Connections seen: " + node.count);
        writeToScreen("trafficcount", "Traffic size: " + node.size);
        writeToScreen("ipaddress", "");
        writeToScreen("lastseen", "Last seen: " + new Date(node.lastseen*1000));
        // TODO: mark that this is hw not ip
    }

    function sendCommand(command, argument) {
        cmd = {}
        cmd['command'] = command;
        cmd['argument'] = argument;
        traffic_ws.send(JSON.stringify(cmd));
    }

    function nodeSelected(event) {
        var nodeId = event.nodes[0];
        if (typeof(nodeId) == 'number' && selectedNodeId != nodeId) {
            updateNodeInfo(nodeId);
            selectedNodeId = nodeId;
            sendCommand("arp2ip", node.address);
            writeToScreen("reversedns", "Reverse DNS: &lt;searching&gt;");
            sendCommand("ip2hostname", node.address);
            writeToScreen("netowner", "Network owner: &lt;searching&gt;");
            sendCommand("ip2netowner", node.address);
        }
        show_sidebar();
    }

    function resetAllNodes() {
        nodes.clear();
        edges.clear();
        nodes.add(nodesArray);
        edges.add(edgesArray);
    }

    function resetAllNodesStabilize() {
        resetAllNodes();
        network.stabilize();
    }

    function setTheData() {
        nodes = new vis.DataSet(nodesArray);
        edges = new vis.DataSet(edgesArray);
        network.setData({nodes:nodes, edges:edges})
    }

    function resetAll() {
        if (network !== null) {
            network.destroy();
            network = null;
        }
        startNetwork();
    }

    function haveNode(ip) {
        return (ip in nodeIds);
    }

    function getNodeId(ip) {
        var nodeName = ip;
        if (ip in nodeNames) {
            nodeName = nodeNames[ip];
        }
        if (ip in nodeIds) {
            return nodeIds[ip];
        } else {
            return null;
        }
    }

    function alertWithObject(m, o) {
        str = m + "\n";
        for(var propertyName in o) {
           // propertyName is what you want
           // you can get the value like this: myObject[propertyName]
           str += propertyName + ": " + o[propertyName] + "\n";
        }
        alert(str);
    }

    function addNode(timestamp, ip, scale, count, size, lwith) {
        var existing = getNodeId(ip);
        // By default, the ip/mac is the node name, but if
        // it is present in the user-set nodeNames dict, use that
        if (existing) {
            var node = nodes.get(existing)
            //alert("node: " + node + " color: " + node['color'] + " size: " + node.size);
            // Set the color to mark 'recent'

            node["size"] += size;
            node["count"] += size;
            node["lastseen"] = timestamp;

            if (scale) {
                node["color"] = 'red';
                node["value"] = node["value"] + size;
            }
            nodes.update(node);
        } else {
            var nodeName = ip;
            if (ip in nodeNames) {
                nodeName = nodeNames[ip];
            }
            var c;
            if (scale) {
                c = 'red';
            } else {
                c = 'gray';
            }
            nodeIds[ip] = curNodeId;
            nodes.add({id:curNodeId,
                       address: ip, // (note: this can also be mac addr)
                       label: nodeName,
                       color: c,
                       value: size,
                       count: count,
                       size: size,
                       lastseen: timestamp,
                       scaling:{
                           min: 1,
                           label: {
                               enabled: true
                           }
                       }
                    });
            curNodeId += 1;
            sendCommand("arp2dhcpname ", ip)
        }
        if (selectedNodeId && selectedNodeId == existing) {
            updateNodeInfo(selectedNodeId);
        }
    }

    function addEdge(from, to) {
        var fromNodeId = nodeIds[from];
        var toNodeId = nodeIds[to];
        var existing = edges.get({
            filter: function(item) {
                return (item.from == fromNodeId && item.to == toNodeId);
            }
        });
        if (existing.length == 0) {
            edges.add({id: curEdgeId, from: fromNodeId, to: toNodeId, color: 'blue'});
            curEdgeId += 1;
        }
    }

    function deleteEdges(nodeId) {
        var toDelete = edges.get({
            filter: function (item) {
                return (item.from == nodeId || item.to == nodeId);
            }
        });
        for (var i=0; i < toDelete.length; i++) {
            var edge = toDelete[i];
            var e = edges.get(edge);
            edges.remove(edge.id);
        }
    }

    function addFlow(timestamp, from, to, count, size) {
        addNode(timestamp, from, false, count, size, "to " + to);
        addNode(timestamp, to, true, count, size, "from " + from);
        addEdge(from, to);
        network.fit({ duration: 500 } );
    }

    startNetwork();

</script>
</body>
</html>
